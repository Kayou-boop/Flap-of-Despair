<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flap of Despair - Franklin, a Tartaruga - INFERNO 66</title>
    <script src="gameover_handler.js" defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* ========================================================= */
        /* --- ESTILOS GERAIS E LAYOUT --- */
        /* ========================================================= */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            /* Base: Azul-claro v√≠vido e Algas Verde-neon */
            background: linear-gradient(to bottom, #AEC6CF, #BADA55);
            font-family: 'Press Start 2P', monospace;
            color: #000000;
            overflow: hidden;
            transition: background 2s ease;
        }
        /* Efeito Vis√£o Submersa (Transi√ß√£o para Paran√≥ia) */
        body.tensao {
            background: linear-gradient(to bottom, #4d0000, #000000); 
        }
        canvas {
            border: 3px solid #00BFFF;
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.5);
            transition: border-color 2s ease, box-shadow 2s ease, background 2s ease;
            cursor: pointer;
        }
        canvas.tensao {
            border-color: #8B0000; 
            box-shadow: 0 0 20px rgba(139, 0, 0, 0.7);
            background: #000000;
        }
        
        /* Efeitos Visuais - Glitch Cl√°ssico e Vis√≠vel */
        .glitch {
            animation: glitch-anim 0.03s steps(2, end) infinite; 
        }
        @keyframes glitch-anim {
            0% { transform: translate(-4px, 4px) skewX(2deg); opacity: 0.9; }
            50% { transform: translate(4px, -4px) skewX(-2deg); opacity: 0.8; }
            100% { transform: translate(0, 0) skewX(0); opacity: 1; }
        }

        /* ========================================================= */
        /* --- INTERFACE E HUD --- */
        /* ========================================================= */
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; display: flex; flex-direction: column; gap: 5px;}
        .voltar-btn {
            padding: 5px 10px; background: #FFFFFF; border: 2px solid #00BFFF;
            color: #000000; font-size: 0.5rem; cursor: pointer; transition: all 0.3s ease;
        }
        .voltar-btn:hover { background: #00BFFF; color: #FFFFFF; border-color: #0080FF; }
        
        #instructions {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            color: #000000; text-align: center; font-size: 0.6rem; text-shadow: 1px 1px 0 #FFFFFF;
            z-index: 10; transition: color 2s ease, text-shadow 2s ease;
        }
        #instructions.tensao { color: #DC143C; text-shadow: 1px 1px 0 #000000; }
        
        #score {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            font-size: 1rem; color: #00BFFF; text-shadow: 1px 1px 0 #000000;
            z-index: 10; transition: color 2s ease; animation: none;
        }
        #score.tensao { color: #DC143C; }
        #score.fatal { animation: blink-fatal 0.3s infinite; color: #FF0000; }
        @keyframes blink-fatal {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        /* --- ENGINEERED TEXT --- */
        #engineered-text {
            position: absolute;
            font-size: 0.8rem;
            color: #FF0000;
            opacity: 0.5; 
            text-shadow: 1px 1px 0 #000000;
            pointer-events: none; 
            display: none;
            animation: text-glitch 0.1s steps(2, end) infinite;
            z-index: 9;
        }
        @keyframes text-glitch {
             0% { transform: translate(1px, -1px) scale(1.02); opacity: 0.5; }
             50% { transform: translate(-1px, 1px) scale(1); opacity: 0.6; }
             100% { transform: translate(0, 0) scale(1.01); opacity: 0.55; }
        }

        /* ========================================================= */
        /* --- TELA DE GAME OVER (ESTILO POPUP SOBRE CEN√ÅRIO) --- */
        /* ========================================================= */
        #gameOver {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            color: #FFFFFF; /* Texto Branco */
            text-align: center; 
            font-size: 1rem;
            background: rgba(0, 0, 0, 0.9); /* Fundo Cinza Escuro/Preto */
            padding: 20px;
            border: 5px solid #8B0000; /* Borda Vermelho Escuro/Marrom */
            border-radius: 5px;
            display: none; 
            z-index: 20; /* Garante que fique acima do canvas */
            font-family: 'Press Start 2P', monospace;
        }
        #gameOver h2 {
            font-size: 2rem;
            color: #FFFFFF; /* T√≠tulo tamb√©m branco */
            margin-bottom: 10px;
        }
        #gameOver p {
            margin-bottom: 20px;
        }
        #gameOver button {
            padding: 10px 20px;
            background: #444444; /* Fundo do bot√£o cinza */
            color: #FFFFFF;
            border: 2px solid #8B0000; /* Borda do bot√£o vermelha escura */
            border-radius: 3px;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.7rem;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
        }
        #gameOver button:hover { 
            background: #8B0000; 
            border-color: #FF0000; 
            transform: scale(1.05);
        }

        /* estilo para o clique secreto */
        #finalScore.clickable {
            cursor: pointer;
            color: #DC143C;
            text-decoration: underline;
        }

        /* ========================================================= */
        /* --- TELAS DE MORTE FATAL --- */
        /* ========================================================= */
        #blackScreen {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: #000000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
            color: #FFFFFF; font-size: 1rem; text-align: center; padding: 20px;
        }
        #fatalLog { 
            color: #FFFFFF; font-size: 0.8rem; margin-bottom: 20px;
            display: none; text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        .error-popup {
            position: absolute; font-size: 0.5rem; color: #DC143C;
            border: 1px solid #FF0000; background: rgba(0, 0, 0, 0.8);
            padding: 5px; animation: text-glitch 0.1s steps(2, end) infinite;
            display: none; max-width: 150px;
        }
        #popup-container { position: absolute; width: 100%; height: 100%; }
        #finalMessage {
            color: #FF0000; font-size: 0.7rem; display: none;
            padding: 20px; text-shadow: 0 0 10px #FF0000;
        }
    </style>
</head>
<body>
    <div id="ui">
        <button class="voltar-btn" onclick="window.location.href='gameover.html'">SELE√á√ÉO</button>
    </div>
    <div id="instructions">Clique ou ESPA√áO para FLAP! üê¢</div>
    <div id="score">Pontos: 0</div>
    <div id="engineered-text">ENGINEERED</div>

    <canvas id="gameCanvas" width="400" height="600"></canvas>

    
    <div id="gameOver">
        <h2 id="goTitle">GAME OVER</h2>
        <p>Pontua√ß√£o Final: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">JOGAR NOVAMENTE</button>
        <button onclick="window.location.href='gameover.html'">SELE√á√ÉO</button>
    </div>

    <div id="blackScreen" style="display: none;">
        <div id="fatalLog"></div>
        <div id="popup-container"></div> 
        <div id="finalMessage"></div>
    </div>


    <script>
    // =========================================================
    // --- VARI√ÅVEIS GLOBAIS E DOM ---
    // =========================================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDiv = document.getElementById('score');
    const gameOverDiv = document.getElementById('gameOver');
    const finalScoreSpan = document.getElementById('finalScore');
    const body = document.body;
    const instructions = document.getElementById('instructions');
    const engineeredTextDiv = document.getElementById('engineered-text');
    const blackScreenDiv = document.getElementById('blackScreen');
    const fatalLogDiv = document.getElementById('fatalLog');
    const finalMessageDiv = document.getElementById('finalMessage');
    const popupContainer = document.getElementById('popup-container');

    let turtle, pipes, score, gameRunning, frame, tensaoMode, modoFatal;
    let tubaraoBloqueador;
    let tubaraoSequenceSpeed; 
    let animationFrameId;
    let pipeGlitchIntensity = 0; 
    let engineeredVisible = false;
    let engineeredBlinkTimer = 0;
    
    // --- CONFIGURA√á√ïES DE JOGO E CONSTANTES ---
    const initialTurtleState = { 
        x: 50, y: 300, 
        width: 50, 
        height: 50, 
        velocity: 0, 
        gravity: 0.6,    
        jump: -7.0,      
        flapDecay: 0.95 
    };
    const pipeGenerationFrequency = 120;
    const basePipeSpeed = 2;
    const pipeWidth = 70; 
    const initialPipeGap = 240; // Gap inicial grande
    const groundHeight = 0; // PISO REMOVIDO: Limite √© o fim da tela
    
    // --- GATILHOS DE DIFICULDADE E MODO ---
    const tensaoScoreThreshold = 30;     
    const engineeredSpreadThreshold = 50; 
    const glitchStartThreshold = 50;     // TREMOR E GLITCH INICIA AQUI
    const preFatalScoreThreshold = 65;     
    const morteFatalScoreThreshold = 66;   
    const difficultyEndScore = 80; // Abertura m√≠nima atinge o limite aqui
    const finalScoreDisplay = 666;         
    const EASTER_EGG_SCORE = 9;
    
    const minGapAtFatal = 100;           // Gap m√≠nimo (ainda razo√°vel)
    const tubaraoAttackSpeedFactor = 5; 
    const tubaraoSequenceMultiplier = 1.5; 
    
    // C√°lculo da redu√ß√£o de gap (LENTO E SUAVE de 50 at√© 80)
    const gapReductionPerScore = (initialPipeGap - minGapAtFatal) / (difficultyEndScore - glitchStartThreshold); 

    // --- MENSAGENS E CONSTANTES ---
    const FINAL_CODE_MESSAGE = "33-555-444-2-7777033-66-4-33-66-444-33-444-777-666-8806660555-2-7777-8-777-66603-330333-777-2-66-55-444-66-5551033-555-330333-33-222-44-666-8806660222-2-66-6660661066-2-6660333-666-444088-6033-777-777-66603-3307777-444-7777-8-33-6-2107-2-777-20555-444-22-33-777-8-2-77706-2-444-7777-444-33107-777-666-222-88-777-33020222-44-2-888-33077-88-330888-666-2106660222-666-3-444-4033102022033055504402";
    const ERROR_MESSAGES = [
        "[FATAL] KERNEL PANIC 0x666", "[ERROR] PREDATOR.EXE NOT FOUND",
        "[WARN] ASSET CORRUPTION DANGER", "[INFO] INITIATING SELF-DESTRUCT",
        "[ERROR] BUFFER OVERFLOW: FRANKLIN", "[FATAL] LOOP DETECTED: 777.666",
        "[CRIT] INTEGRITY CHECK FAIL", "[ERROR] INTEGRITY CHECK FAIL",
        "[WARN] CORRUPT ASSET 0xF00D", "[FATAL] PREDATOR AT THE GATE",
        "[ERROR] RENDER FAIL 0x333", "[CRIT] SYSTEM OVERLOAD (200%)"
    ];
    const NUM_POPUPS = 15; 

    // =========================================================
    // --- UTILIT√ÅRIOS: √ÅUDIO (COM CONTROLE DE ESTADO) ---
    // =========================================================
    let audioContext;
    let noiseSource;

    function initAudio() { 
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
    }
    
    function unlockAudio() {
        initAudio(); 
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                if (tensaoMode && !noiseSource) {
                    startAgressiveNoise();
                }
            });
        }
        document.removeEventListener('mousedown', unlockAudio);
        document.removeEventListener('keydown', unlockAudio);
        document.removeEventListener('touchstart', unlockAudio);
    }
    document.addEventListener('mousedown', unlockAudio);
    document.addEventListener('keydown', unlockAudio);
    document.addEventListener('touchstart', unlockAudio);


    function stopAgressiveNoise() { if (noiseSource) { noiseSource.stop(); noiseSource = null; } }
    function startAgressiveNoise() {
        if (!audioContext || noiseSource || audioContext.state !== 'running') return;
        
        const bufferSize = audioContext.sampleRate * 2;
        const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
        noiseSource = audioContext.createBufferSource();
        noiseSource.buffer = noiseBuffer;
        noiseSource.loop = true;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(500, audioContext.currentTime);
        const gainNode = audioContext.createGain();
        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
        noiseSource.connect(filter).connect(gainNode).connect(audioContext.destination);
        noiseSource.start();
    }
    function playFlapGlitch() { 
        initAudio(); 
        if (audioContext.state === 'suspended') return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(300 + Math.random() * 500, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
        oscillator.connect(gainNode).connect(audioContext.destination);
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.1);
    }
    function playRandomDissonance() {
        if (!tensaoMode || score < (glitchStartThreshold + 1) || Math.random() < 0.98 || audioContext.state === 'suspended') return; 
        initAudio();
        const now = audioContext.currentTime;
        const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.5, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) { data[i] = (Math.random() * 2 - 1) * 0.5; }
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const gainNode = audioContext.createGain();
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        source.connect(gainNode).connect(audioContext.destination);
        source.start(now);
    }
    function playCollisionSound() { 
        initAudio(); 
        if (audioContext.state === 'suspended') return;
        const oscillator = audioContext.createOscillator();
        oscillator.frequency.setValueAtTime(50, audioContext.currentTime);
        const gainNode = audioContext.createGain();
        gainNode.gain.setValueAtTime(0.8, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
        oscillator.connect(gainNode).connect(audioContext.destination);
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.5);
    }
    function playAgressiveGlitchSound() { 
        initAudio();
        if (audioContext.state === 'suspended') return;
        const now = audioContext.currentTime;
        for (let i = 0; i < 5; i++) {
            const oscillator = audioContext.createOscillator();
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(100 + Math.random() * 1000, now + i * 0.05);
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.6, now + i * 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.3);
            oscillator.connect(gainNode).connect(audioContext.destination);
            oscillator.start(now + i * 0.05);
            oscillator.stop(now + i * 0.05 + 0.3);
        }
    }
    function playScoreSound() { initAudio(); if (audioContext.state === 'suspended') return; /* L√≥gica de som */ }


    // =========================================================
    // --- L√ìGICA DE MODOS E GAME OVER ---
    // =========================================================
    
    function activateTensaoVisuals() {
        tensaoMode = true;
        body.classList.add('tensao');
        canvas.classList.add('tensao');
        instructions.classList.add('tensao');
        scoreDiv.classList.add('tensao');
        
        startAgressiveNoise();
    }

    function updateEngineeredTextPosition() {
        if (!tensaoMode) return;
        
        engineeredBlinkTimer = (engineeredBlinkTimer + 1) % 60;
        if (engineeredBlinkTimer < 45) { 
            engineeredVisible = true;
            engineeredTextDiv.style.display = 'block';
        } else {
            engineeredVisible = false;
            engineeredTextDiv.style.display = 'none';
        }

        if (!engineeredVisible) return;

        if (score >= engineeredSpreadThreshold) {
            const rect = engineeredTextDiv.getBoundingClientRect();
            const width = rect.width || 150; 
            const height = rect.height || 20;

            const randomX = Math.random() * (window.innerWidth - width); 
            const randomY = Math.random() * (window.innerHeight - height); 
            
            engineeredTextDiv.style.left = `${randomX}px`;
            engineeredTextDiv.style.top = `${randomY}px`;
            engineeredTextDiv.style.transform = 'none';
        } else {
            engineeredTextDiv.style.top = `${canvas.offsetTop + 50}px`;
            engineeredTextDiv.style.left = '50%';
            engineeredTextDiv.style.transform = 'translateX(-50%)';
        }
    }

    /**
     * Mostra a tela de Game Over como um popup sobre o jogo.
     */
    function showGameOverScreen() {
        finalScoreSpan.textContent = score;
        gameOverDiv.style.display = 'block';
        // REMOVIDO: canvas.style.display = 'none'; para manter o jogo de fundo
        
        if (score === finalScoreDisplay) { // Se a pontua√ß√£o √© 666
            finalScoreSpan.classList.add('clickable');
            finalScoreSpan.onclick = goToFatalMode;
        } else {
            finalScoreSpan.classList.remove('clickable');
            finalScoreSpan.onclick = null;
        }
    }

    function gameOver(isSharkDeath = false) {
        if (!gameRunning) return; 

        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        stopAgressiveNoise();
        playCollisionSound();
        engineeredTextDiv.style.display = 'none'; 

        if (isSharkDeath || modoFatal) {
             morteFatalScreen(isSharkDeath);
             return;
        }
        
        canvas.classList.remove('glitch'); 
        setTimeout(showGameOverScreen, 500); 
    }

    function generatePopups() {
        popupContainer.innerHTML = '';
        for (let i = 0; i < NUM_POPUPS; i++) {
            const popup = document.createElement('div');
            popup.className = 'error-popup';
            popup.textContent = ERROR_MESSAGES[Math.floor(Math.random() * ERROR_MESSAGES.length)];
            
            popup.style.top = `${Math.random() * 90}vh`;
            popup.style.left = `${Math.random() * 90}vw`;
            
            popupContainer.appendChild(popup);
            popup.style.display = 'block';
        }
    }

    function morteFatalScreen(fromShark = false) {
        const initialDelay = fromShark ? 5000 : 0; 
        
        setTimeout(() => {
            blackScreenDiv.style.display = 'flex';
            canvas.style.display = 'none'; 
            playCollisionSound(); 

            setTimeout(() => {
                fatalLogDiv.textContent = "[SYSTEM FAILURE] PREDATOR.EXE ENCOUNTERED A FATAL ERROR. EXIT CODE 666.";
                fatalLogDiv.style.display = 'block';
                playAgressiveGlitchSound();
                
                setTimeout(() => {
                    fatalLogDiv.style.display = 'none';
                    generatePopups(); 
                    
                    setTimeout(() => {
                        popupContainer.innerHTML = ''; 
                        finalMessageDiv.textContent = FINAL_CODE_MESSAGE;
                        finalMessageDiv.style.display = 'block';
                        
                        setTimeout(() => {
                            window.location.href = 'selecao.html';
                        }, 15000); 
                        
                    }, 4000); 
                    
                }, 3000); 
            }, 2500);

        }, initialDelay);
    }

    window.goToFatalMode = function() {
        resetGame(true); // Reinicia o jogo no modo fatal
    }
    
    // =========================================================
    // --- L√ìGICA DO JOGO: RESET / UPDATE ---
    // =========================================================
    function resetGame(directToFatal = false) {
        cancelAnimationFrame(animationFrameId);
        stopAgressiveNoise();

        turtle = { ...initialTurtleState };
        pipes = [];
        score = directToFatal ? morteFatalScoreThreshold : 0;
        gameRunning = true;
        frame = 0;
        
        tubaraoSequenceSpeed = basePipeSpeed * tubaraoAttackSpeedFactor; 
        tensaoMode = score >= tensaoScoreThreshold; 
        modoFatal = directToFatal;
        
        // Inicializa a intensidade do glitch/tremor de canos
        pipeGlitchIntensity = score >= glitchStartThreshold ? 30 : 0; 
        
        engineeredBlinkTimer = 0;
        engineeredVisible = false;

        tubaraoBloqueador = { x: canvas.width + 100, y: canvas.height / 2, speed: 0, size: 100 };
        
        // --- Reset Visuals ---
        scoreDiv.textContent = `Pontos: ${score}`;
        scoreDiv.classList.remove('fatal', 'tensao');
        body.classList.remove('tensao');
        canvas.classList.remove('tensao', 'glitch');
        canvas.style.display = 'block'; 
        instructions.classList.remove('tensao');
        gameOverDiv.style.display = 'none';
        engineeredTextDiv.style.display = 'none';
        blackScreenDiv.style.display = 'none';
        finalScoreSpan.classList.remove('clickable'); 
        finalScoreSpan.onclick = null; 
        popupContainer.innerHTML = ''; 
        fatalLogDiv.style.display = 'none';
        finalMessageDiv.style.display = 'none';

        if (directToFatal) {
            tubaraoBloqueador.x = canvas.width; tubaraoBloqueador.y = turtle.y; 
            tubaraoBloqueador.speed = tubaraoSequenceSpeed;
            scoreDiv.textContent = `Pontos: ${finalScoreDisplay}`; 
            activateTensaoVisuals();
            modoFatal = true;
        } else if (score >= glitchStartThreshold) {
            tubaraoBloqueador.x = canvas.width - 100;
        }
        
        if (tensaoMode) {
            activateTensaoVisuals();
        }

        gameLoop();
    }
    window.restartGame = function() { resetGame(false); } 

    function updateTurtle() {
        turtle.velocity += turtle.gravity;
        turtle.velocity *= turtle.flapDecay;
        turtle.y += turtle.velocity;

        // Colis√£o com o topo/fundo da tela (Piso removido)
        if (turtle.y + turtle.height > canvas.height || turtle.y < 0) {
            gameOver();
        }
    }
    
    function flap() {
        if (!gameRunning) { return; } 
        turtle.velocity = turtle.jump; 
        playFlapGlitch();
    }

    function generatePipes() {
        if (frame % pipeGenerationFrequency === 0) {
            let currentGap = initialPipeGap;
            let randomOffsetY = 0;

            if (score >= morteFatalScoreThreshold || modoFatal) {
                currentGap = 0; 
            } else if (score >= glitchStartThreshold) {
                // L√≥gica da dificuldade de 50 a 80 pontos:
                const progressScore = score - glitchStartThreshold;
                const progressSteps = difficultyEndScore - glitchStartThreshold;
                const currentProgress = Math.min(progressScore, progressSteps);
                const reduction = currentProgress * gapReductionPerScore;
                currentGap = Math.max(minGapAtFatal, initialPipeGap - reduction);
                
                // O tremor/bug visual deve come√ßar no glitchStartThreshold (50) e ser constante.
                // A redu√ß√£o do gap √© o que √© "suave e devagar".
                randomOffsetY = (Math.random() * pipeGlitchIntensity * 0.5) - (pipeGlitchIntensity * 0.25);
            }
            
            const minHeight = 50;
            // C√°lculo sem altura do ch√£o
            const maxTop = canvas.height - currentGap - minHeight; 
            const top = Math.random() * (maxTop - minHeight) + minHeight;
            
            pipes.push({ 
                x: canvas.width, 
                width: pipeWidth, 
                top: top, 
                bottom: canvas.height - top - currentGap, 
                scored: false, 
                gap: currentGap,
                randomOffsetY: randomOffsetY 
            });
        }
    }

    function updatePipes() {
        pipes.forEach((pipe, index) => {
            pipe.x -= basePipeSpeed;
            if (pipe.x + pipe.width < 0) { pipes.splice(index, 1); return; }

            if (score === preFatalScoreThreshold && pipe.x < canvas.width / 2 && !modoFatal) {
                 if (tubaraoBloqueador.speed === 0) {
                     tubaraoBloqueador.speed = tubaraoSequenceSpeed; 
                     tubaraoBloqueador.x = canvas.width;
                 }
            }

            // --- Colis√£o ---
            let currentGlitchY = 0;
            if (pipeGlitchIntensity > 0) {
                 currentGlitchY = (Math.random() * pipeGlitchIntensity) - (pipeGlitchIntensity / 2);
            }
            // Usa o glitch na colis√£o
            const topCollision = pipe.top + currentGlitchY;
            const bottomCollision = canvas.height - pipe.bottom + currentGlitchY;


            if (turtle.x < pipe.x + pipe.width && turtle.x + turtle.width > pipe.x &&
                (turtle.y < topCollision || turtle.y + turtle.height > bottomCollision)) { 
                gameOver();
                return;
            }

            // --- Pontua√ß√£o ---
            if (pipe.x + pipe.width < turtle.x && !pipe.scored) {
                pipe.scored = true; 
                
                if (score < morteFatalScoreThreshold) {
                    score++; 
                } else if (score === morteFatalScoreThreshold) {
                    pipe.x = canvas.width; 
                    score = finalScoreDisplay; 
                    activateMorteFatal();
                    return; 
                }
                
                scoreDiv.textContent = `Pontos: ${score}`; 
                playScoreSound();
                
                if (score === tensaoScoreThreshold && !tensaoMode) { activateTensaoVisuals(); }
            }
        });
    }

    function updateTubarao() {
        if (!tubaraoBloqueador) return;

        if (tubaraoBloqueador.speed === 0) {
             if (score >= glitchStartThreshold && tubaraoBloqueador.x > canvas.width - 100) {
                 tubaraoBloqueador.x -= 0.5;
             }
        } else {
             const targetY = turtle.y + (turtle.height / 2);
             const dy = targetY - tubaraoBloqueador.y;
             tubaraoBloqueador.y += dy * 0.15; 
             tubaraoBloqueador.x -= tubaraoBloqueador.speed;
             
             // Colis√£o com o tubar√£o
             const sharkHitboxX = tubaraoBloqueador.x + 20; 
             const sharkHitboxWidth = tubaraoBloqueador.size - 40;
             const sharkHitboxY = tubaraoBloqueador.y - 30;
             const sharkHitboxHeight = 60;

             if (turtle.x < sharkHitboxX + sharkHitboxWidth &&
                 turtle.x + turtle.width > sharkHitboxX &&
                 turtle.y < sharkHitboxY + sharkHitboxHeight &&
                 turtle.y + turtle.height > sharkHitboxY) {
                 
                 gameOver(true);
                 return;
             }
         
             if (tubaraoBloqueador.x + tubaraoBloqueador.size < 0) {
                 if (modoFatal) {
                     tubaraoSequenceSpeed *= tubaraoSequenceMultiplier;
                     tubaraoBloqueador.x = canvas.width;
                     tubaraoBloqueador.y = turtle.y; 
                     tubaraoBloqueador.speed = tubaraoSequenceSpeed;
                 }
             }
        }
    }

    function activateMorteFatal() {
        if (modoFatal) return; 
        modoFatal = true;
        
        if (tubaraoBloqueador.speed === 0) {
            tubaraoBloqueador.speed = tubaraoSequenceSpeed;
            tubaraoBloqueador.x = canvas.width;
            tubaraoBloqueador.y = turtle.y;
        }
    }
    
    // =========================================================
    // --- FUN√á√ïES DE DESENHO ---
    // =========================================================

    function drawBackground() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const color1 = tensaoMode ? '#4d0000' : '#87CEEB'; 
        const color2 = tensaoMode ? '#000000' : '#AEC6CF'; 
        
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, color1);
        gradient.addColorStop(1, color2);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height); 
    }

    function drawTurtle() {
        ctx.save();
        ctx.translate(turtle.x + turtle.width / 2, turtle.y + turtle.height / 2); 
        ctx.rotate(turtle.velocity * 0.03); 
        ctx.font = '50px Arial';
        ctx.fillStyle = tensaoMode ? '#FF0000' : '#008000';
        ctx.fillText('üê¢', -25, 25); 
        ctx.restore();
    }

    function drawPipes() {
        pipes.forEach(pipe => {
            const pipeColor = tensaoMode ? '#8B0000' : '#39FF14'; 
            const borderColor = tensaoMode ? '#4d0000' : '#228B22';
            
            let currentGlitchY = 0;
            if (pipeGlitchIntensity > 0) {
                 currentGlitchY = (Math.random() * pipeGlitchIntensity) - (pipeGlitchIntensity / 2);
            }

            // Aplica o glitch/tremor visualmente
            const topY = pipe.top + currentGlitchY;
            const bottomY = canvas.height - pipe.bottom + currentGlitchY;

            ctx.fillStyle = pipeColor;
            ctx.fillRect(pipe.x, 0, pipe.width, topY);
            
            ctx.fillRect(pipe.x, bottomY, pipe.width, pipe.bottom);
            
            const capHeight = 20;
            ctx.fillStyle = borderColor;
            ctx.fillRect(pipe.x - 2, topY - capHeight, pipe.width + 4, capHeight);
            ctx.fillRect(pipe.x - 2, bottomY, pipe.width + 4, capHeight);
        });

        if (tubaraoBloqueador && tubaraoBloqueador.x < canvas.width + 10) {
             ctx.font = tubaraoBloqueador.size + 'px Arial';
             ctx.fillStyle = '#FF0000';
             ctx.fillText('ü¶à', tubaraoBloqueador.x, tubaraoBloqueador.y);
        }
    }


    // =========================================================
    // --- O LOOP PRINCIPAL ---
    // =========================================================
    function gameLoop() {
        if (!gameRunning) { return; }

        frame++;
        
        updatePipes();
        updateTurtle(); 
        updateTubarao(); 
        generatePipes();
        
        // Atualiza a intensidade do tremor se o score for >= 50
        if (score >= glitchStartThreshold && pipeGlitchIntensity === 0) {
             pipeGlitchIntensity = 30; // Come√ßa o tremor com intensidade 30
        }

        if (tensaoMode) {
            updateEngineeredTextPosition();
        }

        drawBackground();
        drawPipes();
        drawTurtle();
        
        playRandomDissonance(); 

        if (tensaoMode) {
             if (frame % 10 < 1) { 
                 canvas.classList.add('glitch');
             } else {
                 canvas.classList.remove('glitch');
             }
        } else {
             canvas.classList.remove('glitch');
        }

        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // =========================================================
    // --- CONTROLES MANUAIS ---
    // =========================================================
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.key === ' ') {
            if (gameRunning) {
                e.preventDefault(); 
                flap();
            } else if (!gameRunning && gameOverDiv.style.display === 'block') {
                // Ao pressionar espa√ßo na tela de Game Over, reinicia o jogo
                restartGame();
            }
        }
    });

    canvas.addEventListener('mousedown', (e) => {
        if (gameRunning) {
            e.preventDefault(); 
            flap();
        } 
    });
    canvas.addEventListener('touchstart', (e) => {
        if (gameRunning) {
            e.preventDefault(); 
            flap();
        } 
    });


    // Iniciar o jogo
    resetGame();
    </script>
</body>
</html>
