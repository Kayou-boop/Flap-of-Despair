<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flap of Despair - Maisie, a Abelha - ATO III</title>
    <script src="gameover_handler.js" defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* ========================================================= */
        /* --- ESTILOS GERAIS E CENÁRIO --- */
        /* ========================================================= */
        * {
            user-select: none;
            box-sizing: border-box;
            transition: background-color 1.5s ease-in-out, border-color 1.5s ease-in-out, filter 0.5s ease-in-out; 
        }

        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', monospace;
            color: #000000;
            overflow: hidden;
            /* Fundo Inicial Listrado Amarelo e Preto */
            background: repeating-linear-gradient(
                0deg,
                #000000,
                #000000 25px,
                #FFD700 25px,
                #FFD700 50px
            );
        }
        /* MODO CORRUPÇÃO 30 */
        body.corrupted-bg {
            background: linear-gradient(0deg, #330000 0%, #660000 100%);
        }
        /* MODO DARK GLITCH */
        body.dark-glitch-bg {
             background: linear-gradient(0deg, #100000 0%, #200000 100%);
        }

        /* GLITCH EXTREMO (INVERSÃO DE CORES TEMPORÁRIA) */
        body.inverted {
            filter: invert(100%) hue-rotate(180deg);
            transition: filter 0.05s; 
        }
        
        #game-container {
            width: 400px; 
            height: 600px;
            background-color: #795548; /* Marrom Inicial */
            border: 8px solid #000000; 
            position: relative;
            overflow: hidden;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            margin-top: 10px; 
        }
        /* MODO CORRUPÇÃO 30 (Fundo do Jogo - Sombrio) */
        #game-container.corrupted-bg {
            background-color: #1C1C1C; 
            border-color: #DC143C; 
            box-shadow: 0 0 30px rgba(220, 20, 60, 0.9);
        }
        /* MODO DARK GLITCH */
        #game-container.dark-glitch-bg {
            background-color: #000000; 
            border-color: #DC143C; 
        }

        /* ========================================================= */
        /* --- ELEMENTOS DE JOGO --- */
        /* ========================================================= */
        #player {
            position: absolute;
            top: 250px; left: 50px; 
            font-size: 35px; 
            z-index: 20;
            filter: drop-shadow(0 0 2px #FFD700); 
            transition: transform 0.1s ease-out, filter 0.5s ease-in-out;
        }
        
        /* EFEITO DE INVULNERABILIDADE (FLOR - AZUL) */
        #player.invulnerable {
            filter: drop-shadow(0 0 5px #00BFFF) drop-shadow(0 0 10px #00BFFF);
            animation: pulse-blue 0.2s infinite alternate;
        }
        @keyframes pulse-blue {
            from { filter: drop-shadow(0 0 5px #00BFFF); }
            to { filter: drop-shadow(0 0 15px #00BFFF); }
        }

        /* EFEITO DARK GLITCH (CAVEIRA - VERMELHO PERMANENTE) */
        #player.dark-glitch-player {
            filter: drop-shadow(0 0 5px #DC143C) drop-shadow(0 0 10px #DC143C);
            animation: pulse-red 0.2s infinite alternate; 
        }
        @keyframes pulse-red {
            from { filter: drop-shadow(0 0 5px #DC143C); }
            to { filter: drop-shadow(0 0 15px #DC143C); }
        }

        .pipe {
            position: absolute;
            width: 60px;
            background-color: #FFD700; 
            border: 3px solid #000000; 
            z-index: 5;
            transition: background-color 1.5s ease-in-out, transform 0.05s linear; 
        }
        .pipe.corrupted-pipe {
            background-color: #8B0000; 
        }
        .pipe.shaking {
            animation: shake 0.1s infinite;
        }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            100% { transform: translate(-1px, -1px) rotate(1deg); }
        }

        .falling-cross {
            position: absolute;
            font-size: 30px; 
            color: #DC143C;
            transform: scaleY(-1); 
            z-index: 50; 
        }
        
        .score-66-item, .flower {
            position: absolute;
            font-size: 30px; 
            line-height: 1;
            z-index: 15;
            animation: pulse 1.5s infinite alternate; 
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        
        /* INIMIGOS PERSEGUIDORES (CHASER) */
        .chaser {
            position: absolute;
            font-size: 40px; 
            line-height: 1;
            z-index: 100; 
            transition: transform 0.05s linear;
        }
        .chaser.shrimp {
            color: #800000; 
            filter: drop-shadow(0 0 5px #DC143C);
        }
        .chaser.turtle {
            color: #A9A9A9; 
            filter: drop-shadow(0 0 5px #000000);
        }
        .chaser.bear {
            color: #4B0082; 
            filter: drop-shadow(0 0 5px #FFD700);
        }

        /* ========================================================= */
        /* --- UI E POSICIONAMENTO (TRANSPARENTE E ORGANIZADO) --- */
        /* ========================================================= */
        #top-container {
            width: 400px; 
            margin-top: 10px;
            position: relative;
            z-index: 55;
        }
        
        /* REMOÇÃO DO BACKGROUND E BORDA DA PONTUAÇÃO E TEXTO AUXILIAR */
        #top-ui {
            width: 100%;
            color: #FFFFFF;
            text-shadow: 2px 2px 0 #000000;
            padding: 5px 0;
            background: transparent; 
            border: none; 
            text-align: center; 
        }
        
        #instruction-text {
            font-size: 0.6rem; 
            color: #FFFFFF;
            margin-bottom: 5px;
        }
        
        /* ESTILO DO EASTER EGG: Borda transparente, cor branca misturada com o texto, tamanho minúsculo */
        #boost-cheat-trigger {
            font-size: 0.1rem; /* Quase invisível */
            color: #ffffff01; /* Cor muito transparente */
            cursor: pointer;
            text-decoration: none;
            margin: 0 5px; /* Para garantir que o clique pegue a área */
            display: inline-block;
            line-height: 0;
            padding: 0 2px;
        }
        
        #score-external {
            font-size: 1rem;
            margin-bottom: 5px; 
        }
        #powerup-timer {
            font-size: 0.8rem;
            color: #00BFFF; 
            text-shadow: 2px 2px 0 #000000;
            min-height: 1rem;
        }
        
        /* Botão SELEÇÃO no canto superior esquerdo */
        .voltar-btn {
            position: absolute;
            top: 0; left: 0;
            padding: 5px 10px;
            background: #444444;
            color: #FFFFFF;
            border: 2px solid #FFD700;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.6rem;
            cursor: pointer;
        }

        /* TELAS DE FIM DE JOGO */
        #screen-fade-to-black {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #000000;
            opacity: 0;
            display: none;
            z-index: 9000;
            transition: opacity 2s ease-in;
            pointer-events: none;
        }
        #screen-fade-to-black.active {
            display: block;
            opacity: 1;
        }

        #gameOver {
            position: absolute; 
            top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #FFFFFF;
            text-align: center; 
            font-size: 1rem;
            background: #000000; 
            padding: 20px 30px;
            border: 5px solid #DC143C; 
            border-radius: 5px;
            display: none; 
            z-index: 60; 
            font-family: 'Press Start 2P', monospace;
            box-shadow: 0 0 25px 5px rgba(220, 20, 60, 0.9);
        }
        #gameOver h2 { font-size: 2.2rem; color: #DC143C; margin-bottom: 10px; }
        #gameOver p { 
            margin-bottom: 10px; 
            font-size: 0.8rem;
            color: #FFD700;
        }
        #gameOver button {
            padding: 10px 20px;
            background: #222222; 
            color: #FFFFFF;
            border: 2px solid #DC143C; 
            font-family: 'Press Start 2P', monospace;
            font-size: 0.7rem;
            cursor: pointer;
            margin: 5px;
            transition: all 0.1s ease;
        }
        
        #fatal-screen {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #DC143C;
            text-shadow: 0 0 5px #DC143C;
            z-index: 9000;
            font-size: 1rem;
            padding: 20px;
        }
        #fatal-screen.glitch-active {
            animation: static-noise 0.2s steps(4) infinite;
        }
    </style>
</head>
<body>
    
    <div id="top-container">
        <button class="voltar-btn" onclick="window.location.href = 'gameover.html';">SELEÇÃO</button>
        <div id="top-ui">
            <div id="instruction-text">
                CLIQUE OU SEGURE ESPAÇO PARA ACELERAR
                <span id="boost-cheat-trigger">BOOST</span>!
            </div>
            <div id="score-external">
                PONTOS: <span id="currentScore">0</span>
            </div>
            <div id="powerup-timer"></div>
        </div>
    </div>

    <div id="game-container">
        <div id="player">🐝</div>
        <div id="screen-fade-to-black"></div> 
    </div>
    
    <div id="gameOver">
        <h2 id="goTitle">GAME OVER</h2>
        <p>Pontuação Final: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">JOGAR NOVAMENTE</button>
        <button onclick="window.location.href = 'gameover.html';">MENU</button>
    </div>

    <div id="fatal-screen">
        <div id="fatal-log">...</div>
        <div id="final-message"></div>
    </div>

    <script>
        // =========================================================
        // 1. CONSTANTES E VARIÁVEIS DE JOGO
        // =========================================================
        const gameContainer = document.getElementById('game-container');
        const player = document.getElementById('player');
        const currentScoreSpan = document.getElementById('currentScore');
        const powerupTimerDisplay = document.getElementById('powerup-timer');
        const gameOverDiv = document.getElementById('gameOver');
        const finalScoreSpan = document.getElementById('finalScore');
        const fatalScreen = document.getElementById('fatal-screen');
        const fatalLog = document.getElementById('fatal-log');
        const finalMessage = document.getElementById('final-message');
        const fadeToBlackScreen = document.getElementById('screen-fade-to-black');
        
        // NOVO: Gatilho de Easter Egg
        const boostCheatTrigger = document.getElementById('boost-cheat-trigger');

        const GAME_HEIGHT = 600;
        const GAME_WIDTH = 400;
        const PLAYER_SIZE = 35; 
        const PIPE_WIDTH = 60;
        const INITIAL_GAP_SIZE = 250; 
        const GRAVITY = 0.3; 
        const BOOST_GAIN = -0.7; 
        const INVULNERABLE_DURATION = 3000; 
        const PIPE_SPEED = 3;
        
        const FLOWER_EMOJIS = ['🌹', '🏵️', '🌸', '🌷', '🌻'];
        const DARK_SKULL_EMOJI = '☠️'; 
        const FATAL_BEAR_EMOJI = '🐻';
        const FATAL_SHRIMP_EMOJI = '🦐'; 
        const FATAL_TURTLE_EMOJI = '🐢'; 
        
        const FLOWER_RARITY = 0.25; 
        const CRITICAL_SCORE = 66; 
        
        const CORRUPTION_START_SCORE = 30; 
        const GLITCH_START_SCORE = 35; 
        const EXTREME_GLITCH_START_SCORE = 40; 
        const FALLING_CROSS_START_SCORE = 50;  
        const CHASER_EVENT_SCORE = 88; 

        
        const DARK_GLITCH_INVERSE_CHANCE = 0.03; 
        const DARK_GLITCH_PIPE_SHAKE_INTERVAL = 300; 
        
        let velocity = 0;
        let isPlaying = false;
        let score = 0;
        let pipes = [];
        let flowers = [];
        let crosses = []; 
        let score66Item = null; 
        let animationFrameId;

        let isBoosting = false;
        let isInvulnerable = false;
        let boostOscillator = null; 
        let audioContext = null; 

        let isCorrupted = false; 
        let isGlitching = false; 
        let isExtremeGlitching = false; 
        let isFallingCrossActive = false; 
        let isDarkGlitchActive = false; 
        let isChaserActive = false; 
        let chaserSpeedMultiplier = 1; 

        let glitchTimer = null; 
        let inverseColorTimer = null; 
        let crossInterval = null; 
        let chaser = null; 
        let bearAccelerationTimer = null;
        let extremeGlitchTempTimer = null; 
        let hasSpawned66Item = false; 


        // =========================================================
        // 2. FUNÇÕES DE ÁUDIO
        // =========================================================
        
        function initAudio() { 
            if (!audioContext) { 
                audioContext = new (window.AudioContext || window.webkitAudioContext)(); 
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }
        
        function playTone(freq, duration, volume = 0.5, type = 'square') {
            if (!audioContext) return; 
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start();
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playCorruptionSound() {
            if (!audioContext) return;
            const bufferSize = audioContext.sampleRate * 0.5;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const source = audioContext.createBufferSource();
            source.buffer = buffer;

            const gainNode = audioContext.createGain();
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.5);

            source.start();
        }

        function startBoostSound() { 
            if (!audioContext) return;
            if (boostOscillator) return; 

            const baseFreq = isDarkGlitchActive ? 150 : 250; 
            
            boostOscillator = audioContext.createOscillator();
            boostOscillator.type = 'sine'; 
            boostOscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);

            const fmGain = audioContext.createGain();
            fmGain.gain.setValueAtTime(25, audioContext.currentTime); 
            
            const fmOscillator = audioContext.createOscillator();
            fmOscillator.type = 'square'; 
            fmOscillator.frequency.setValueAtTime(12, audioContext.currentTime); 
            
            fmOscillator.connect(fmGain);
            fmGain.connect(boostOscillator.frequency);

            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.08, audioContext.currentTime); 
            
            boostOscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            fmOscillator.start();
            boostOscillator.start();
            
            boostOscillator.fmOscillator = fmOscillator; 
        }
        
        function stopBoostSound() { 
            if (boostOscillator) {
                if (boostOscillator.fmOscillator) {
                    boostOscillator.fmOscillator.stop(audioContext.currentTime + 0.1);
                }
                boostOscillator.stop(audioContext.currentTime + 0.1); 
                boostOscillator = null;
            }
        }

        function playScoreSound() { playTone(880, 0.1, 0.3); }
        function playPowerUpSound() { 
            playTone(660, 0.05, 0.5);
            setTimeout(() => playTone(880, 0.05, 0.5), 60);
        }
        function playCollisionSound() { playTone(100, 0.3, 0.6); }
        function playGlitchSound() {
            playTone(50, 0.1);
            setTimeout(() => playTone(300, 0.1), 50);
        }
        function playChaserSound() {
             playTone(200, 0.5, 0.7, 'sawtooth');
             playTone(100, 0.5, 0.7, 'sawtooth');
        }


        // =========================================================
        // 3. FUNÇÕES DE CRIAÇÃO 
        // =========================================================

        function createPipe() { 
            let currentGapSize = INITIAL_GAP_SIZE; 
            
            const minCenter = currentGapSize / 2 + 30;
            const maxCenter = GAME_HEIGHT - currentGapSize / 2 - 30;
            let centerPosition = Math.floor(Math.random() * (maxCenter - minCenter) + minCenter);

            let isHorizontal = false;
            // Se ExtremeGlitch (Score 40) ou temporário (Score 35) estiver ativo, há chance de horizontal
            if ((isExtremeGlitching || extremeGlitchTempTimer !== null) && Math.random() < 0.15) { 
                isHorizontal = true;
                currentGapSize = 100; 
                centerPosition = Math.floor(Math.random() * (GAME_HEIGHT - 30) + 15);
            }

            const topPipeHeight = isHorizontal ? 0 : centerPosition - (currentGapSize / 2);
            const bottomPipeHeight = isHorizontal ? 0 : GAME_HEIGHT - (centerPosition + (currentGapSize / 2));

            const pipe = {
                x: GAME_WIDTH,
                gapCenter: centerPosition,
                gapSize: currentGapSize,
                scored: false,
                elementTop: document.createElement('div'),
                elementBottom: document.createElement('div'),
                isHorizontal: isHorizontal
            };
            
            pipe.elementTop.className = 'pipe top';
            pipe.elementBottom.className = 'pipe bottom';
            
            if (isCorrupted) {
                pipe.elementTop.classList.add('corrupted-pipe');
                pipe.elementBottom.classList.add('corrupted-pipe');
            }

            if (isHorizontal) {
                pipe.elementTop.remove(); // Remove o topo para cano horizontal
                pipe.elementBottom.style.height = '30px'; 
                pipe.elementBottom.style.width = `${GAME_WIDTH}px`; 
                pipe.elementBottom.style.left = `${pipe.x}px`;
                pipe.elementBottom.style.bottom = 'unset';
                pipe.elementBottom.style.top = `${centerPosition}px`;
            } else {
                pipe.elementTop.style.height = `${topPipeHeight}px`;
                pipe.elementTop.style.left = `${pipe.x}px`;
                pipe.elementTop.style.top = '0';

                pipe.elementBottom.style.height = `${bottomPipeHeight}px`;
                pipe.elementBottom.style.left = `${pipe.x}px`;
                pipe.elementBottom.style.bottom = '0';
                
                gameContainer.appendChild(pipe.elementTop);
            }
            gameContainer.appendChild(pipe.elementBottom);
            pipes.push(pipe);
            
            // LÓGICA DE GERAÇÃO DE ITENS (Score 66 - Garantido)
            if (score >= CRITICAL_SCORE && !hasSpawned66Item) { 
                 hasSpawned66Item = true; // Garante que só spawne uma vez
                 // 50% de chance para Urso (Fatal) ou Caveira (Dark Glitch)
                 const itemEmoji = Math.random() < 0.5 ? FATAL_BEAR_EMOJI : DARK_SKULL_EMOJI;
                 createScore66Item(pipe.x, pipe.gapCenter, pipe.gapSize, itemEmoji);
            } else if (score < CORRUPTION_START_SCORE && Math.random() < FLOWER_RARITY) { 
                // A flor só aparece antes do modo corrupção (Score 30)
                createFlower(pipe.x, pipe.gapCenter, pipe.gapSize);
            }
        }

        function createFlower(pipeX, gapCenter, gapSize) { 
            const emoji = FLOWER_EMOJIS[Math.floor(Math.random() * FLOWER_EMOJIS.length)];
            const flowerElement = document.createElement('div');
            
            const maxOffset = Math.min(gapSize / 2 - 30, 50); 
            const yOffset = Math.random() * maxOffset * 2 - maxOffset;
            const yPosition = gapCenter + yOffset - 15; 
            
            const xPosition = pipeX + PIPE_WIDTH + 20;

            const flower = {
                x: xPosition,
                y: yPosition,
                element: flowerElement
            };
            
            flowerElement.className = 'flower';
            flowerElement.textContent = emoji;
            flowerElement.style.top = `${flower.y}px`;
            flowerElement.style.left = `${flower.x}px`;
            
            gameContainer.appendChild(flowerElement);
            flowers.push(flower);
        }

        function createScore66Item(pipeX, gapCenter, gapSize, emoji) {
            // Se já existe um, não cria
            if(score66Item) return;

            const itemElement = document.createElement('div');
            itemElement.className = 'score-66-item';
            itemElement.textContent = emoji;

            // Posição ajustada: O item aparecerá no meio do buraco
            const yPosition = gapCenter - 15; 
            const xPosition = pipeX + PIPE_WIDTH + 20;
            
            const item = {
                x: xPosition,
                y: yPosition,
                element: itemElement,
                emoji: emoji
            };

            itemElement.style.top = `${item.y}px`;
            itemElement.style.left = `${item.x}px`;
            
            gameContainer.appendChild(itemElement);
            score66Item = item;
        }

        function createFallingCross() { 
            if (!isPlaying) return;
            const crossElement = document.createElement('div');
            
            // NOVO: A cruz começa ACIMA da tela
            const xPosition = Math.random() * (GAME_WIDTH - 30);
            const initialY = -30; 
            
            // NOVO: Velocidade positiva (descida)
            const speed = 1 + Math.random() * 2;
            
            crossElement.className = 'falling-cross';
            crossElement.textContent = '†'; 
            
            crossElement.style.left = `${xPosition}px`;
            crossElement.style.top = `${initialY}px`;

            const cross = {
                x: xPosition,
                y: initialY,
                speed: speed, // Velocidade de descida
                element: crossElement
            };
            
            gameContainer.appendChild(crossElement);
            crosses.push(cross);
        }


        // =========================================================
        // 4. FUNÇÕES DE ESTADO DO MODO CORRUPÇÃO E GLITCH
        // =========================================================
        
        function activateCorruptionMode() { 
            if (isCorrupted) return;
            isCorrupted = true;
            
            playCorruptionSound(); 
            
            document.body.classList.add('corrupted-bg');
            gameContainer.classList.add('corrupted-bg');
            
            pipes.forEach(pipe => {
                pipe.elementTop.classList.add('corrupted-pipe');
                pipe.elementBottom.classList.add('corrupted-pipe');
            });
        }
        
        function glitchScore() { 
            if (!glitchTimer) {
                const originalScore = currentScoreSpan.textContent;
                currentScoreSpan.textContent = Math.floor(Math.random() * 999);
                playGlitchSound();
                
                glitchTimer = setTimeout(() => {
                    currentScoreSpan.textContent = originalScore;
                    glitchTimer = null;
                }, 100); 
            }
        }
        
        function invertColors() { 
             if (inverseColorTimer || !isPlaying) return;
             
             playGlitchSound();
             document.body.classList.add('inverted');
             
             inverseColorTimer = setTimeout(() => {
                 document.body.classList.remove('inverted');
                 inverseColorTimer = null;
             }, 100); 
        }

        function activateGlitchMode() { 
            if (isGlitching) return;
            isGlitching = true;
        }
        
        function activateExtremeGlitchMode(isTemporary = false) { 
            if (isExtremeGlitching && !isTemporary) return;

            if (extremeGlitchTempTimer) clearTimeout(extremeGlitchTempTimer);
            
            if (!isTemporary) {
                isExtremeGlitching = true;
            }

            const shakeInterval = isDarkGlitchActive ? DARK_GLITCH_PIPE_SHAKE_INTERVAL : 500;
            glitchPipesConstantly(shakeInterval);
            
            if (isTemporary) {
                extremeGlitchTempTimer = setTimeout(() => {
                    extremeGlitchTempTimer = null;
                    if (!isExtremeGlitching) {
                         pipes.forEach(pipe => {
                            pipe.elementTop.classList.remove('shaking');
                            pipe.elementBottom.classList.remove('shaking');
                         });
                    }
                }, 500); // 0.5 segundos de glitch extremo
            }
        }

        function glitchPipesConstantly(interval) { 
            if (!isExtremeGlitching && extremeGlitchTempTimer === null || !isPlaying) return;
            
            pipes.forEach(pipe => {
                pipe.elementTop.classList.remove('shaking');
                pipe.elementBottom.classList.remove('shaking');
            });

            if (pipes.length > 0) {
                const pipeIndex = Math.floor(Math.random() * pipes.length);
                pipes[pipeIndex].elementBottom.classList.add('shaking'); 
                if (pipes[pipeIndex].elementTop) {
                     pipes[pipeIndex].elementTop.classList.add('shaking');
                }
            }

            if (isExtremeGlitching || extremeGlitchTempTimer !== null) {
                setTimeout(() => glitchPipesConstantly(interval), interval); 
            }
        }

        function activateFallingCrossMode() { 
            if (isFallingCrossActive) return;
            isFallingCrossActive = true;
            
            const baseInterval = 1500; 
            
            function setCrossInterval() {
                if (!isPlaying) return;
                createFallingCross();
                const freqDecrease = Math.max(0, (score - FALLING_CROSS_START_SCORE) * 20);
                const newInterval = Math.max(500, baseInterval - freqDecrease); 
                
                if (crossInterval) { clearTimeout(crossInterval); }
                crossInterval = setTimeout(setCrossInterval, newInterval);
            }
            
            setCrossInterval();
        }
        
        function activateDarkGlitch() { 
            if (isDarkGlitchActive) return;
            isDarkGlitchActive = true;
            
            document.body.classList.add('dark-glitch-bg');
            gameContainer.classList.add('dark-glitch-bg');
            player.classList.add('dark-glitch-player');
        }


        // =========================================================
        // 5. EVENTO CHASER (SCORE 88) 
        // =========================================================

        function startChaserEvent(isBrutal = false) { 
            // Se já tem um chaser, e este não é brutal, não inicia um novo
            if (isChaserActive && !isBrutal) return;
            
            isChaserActive = true;
            
            // Limpa o palco (Importante para o skip)
            [...gameContainer.querySelectorAll('.pipe, .flower, .falling-cross')].forEach(el => el.remove());
            pipes = [];
            flowers = [];
            crosses = [];

            const choice = Math.floor(Math.random() * 3);
            const chaserElement = document.createElement('div');
            chaserElement.className = 'chaser';
            
            const startX = GAME_WIDTH + 50; 
            const startY = GAME_HEIGHT / 2; 
            
            // Aumenta o multiplicador de velocidade se for brutal
            if (isBrutal) {
                chaserSpeedMultiplier *= 1.5;
            }

            chaser = {
                element: chaserElement,
                x: startX,
                y: startY,
                speedX: 0,
                baseSpeed: PIPE_SPEED * chaserSpeedMultiplier, // Aplica o multiplicador
                targetSpeed: 0, 
                type: choice
            };
            
            switch (choice) {
                case 0: // 🦐 (Lento)
                    chaser.element.textContent = FATAL_SHRIMP_EMOJI;
                    chaser.element.classList.add('shrimp');
                    chaser.targetSpeed = 1.5 * chaserSpeedMultiplier; 
                    break;
                case 1: // 🐢 (Rápido)
                    chaser.element.textContent = FATAL_TURTLE_EMOJI;
                    chaser.element.classList.add('turtle');
                    chaser.targetSpeed = 6 * chaserSpeedMultiplier; 
                    break;
                case 2: // 🐻 (Perseguição em duas fases)
                    chaser.element.textContent = FATAL_BEAR_EMOJI;
                    chaser.element.classList.add('bear');
                    chaser.targetSpeed = 0; 
                    chaser.bearPhase = 0; 

                    bearAccelerationTimer = setTimeout(() => {
                        chaser.bearPhase = 1;
                        chaser.targetSpeed = 10 * chaserSpeedMultiplier; 
                    }, 3000 / chaserSpeedMultiplier); // Reduz o tempo de espera se brutal
                    
                    break;
            }

            chaser.element.style.top = `${chaser.y}px`;
            chaser.element.style.left = `${chaser.x}px`;
            gameContainer.appendChild(chaser.element);
            playChaserSound();
        }

        function updateChaserMovement() { 
            if (!chaser || !isPlaying) return;
            
            const playerCenterY = player.offsetTop + PLAYER_SIZE / 2;
            const chaserCenterY = chaser.y + 20; 
            
            // Acelera o Chaser até a TargetSpeed
            chaser.speedX = Math.min(chaser.speedX + 0.05, chaser.targetSpeed);

            if (chaser.type === 2) { 
                if (chaser.bearPhase === 0) {
                     chaser.x -= PIPE_SPEED; 
                     chaser.y += (playerCenterY - chaserCenterY) * 0.01;
                } else { 
                     chaser.x -= chaser.speedX;
                     chaser.y += (playerCenterY - chaserCenterY) * 0.08 * chaserSpeedMultiplier; // Maior perseguição vertical
                }
            } else {
                 chaser.x -= chaser.speedX;
                 chaser.y += (playerCenterY - chaserCenterY) * 0.05 * chaserSpeedMultiplier; // Maior perseguição vertical
            }

            // Atualiza a posição visual
            chaser.element.style.left = `${chaser.x}px`;
            chaser.element.style.top = `${chaser.y}px`;
            
            // Checa se o chaser saiu da tela (sobra)
            if (chaser.x < -100) {
                chaser.element.remove();
                chaser = null;
                isChaserActive = false;
                
                // Se esquivou, o próximo é brutal!
                startChaserEvent(true); 
                return;
            }

            // Rotação sutil
            const directionY = playerCenterY > chaserCenterY ? 1 : -1;
            const rotation = Math.atan2(directionY, -1) * (180 / Math.PI) * 0.5;
            chaser.element.style.transform = `rotate(${rotation}deg)`;
        }


        // =========================================================
        // 6. LOOP PRINCIPAL, FÍSICA E MOVIMENTO
        // =========================================================

        function updateGame() {
            if (!isPlaying) return;
            
            // Checagens de ativação dos modos
            if (score >= CORRUPTION_START_SCORE && !isCorrupted) { activateCorruptionMode(); }
            if (score >= GLITCH_START_SCORE && !isGlitching) { activateGlitchMode(); }
            if (score >= EXTREME_GLITCH_START_SCORE && !isExtremeGlitching) { activateExtremeGlitchMode(false); }
            if (score >= FALLING_CROSS_START_SCORE && !isFallingCrossActive) { activateFallingCrossMode(); }
            if (score >= CHASER_EVENT_SCORE && !isChaserActive) { startChaserEvent(false); } 

            // Lógica de glitch
            const inverseChance = isDarkGlitchActive ? DARK_GLITCH_INVERSE_CHANCE : 0.01;
            if (isGlitching && Math.random() < 0.005) { glitchScore(); } 
            if (isExtremeGlitching && Math.random() < inverseChance) { invertColors(); }
            
            // Glitch agressivo e temporário no score 35
            if (isGlitching && !isExtremeGlitching && extremeGlitchTempTimer === null && Math.random() < 0.015) {
                activateExtremeGlitchMode(true);
                playGlitchSound();
            }
            
            // 6.1 Atualiza a posição da Maisie
            if (isBoosting) { velocity += BOOST_GAIN; }
            velocity += GRAVITY;
            let playerTop = player.offsetTop + velocity;
            let playerLeft = player.offsetLeft;
            let rotation = Math.max(Math.min(velocity * 4, 30), -30);
            player.style.transform = `rotate(${rotation}deg)`;

            // Colisão Teto/Chão
            if (playerTop <= 0 || playerTop + PLAYER_SIZE >= GAME_HEIGHT) {
                playerTop = playerTop <= 0 ? 0 : GAME_HEIGHT - PLAYER_SIZE;
                gameOver(false);
                return;
            }
            player.style.top = `${playerTop}px`;
            
            // 6.2 Movimento dos Canos e Pontuação
            if (!isChaserActive) { 
                let i = pipes.length;
                while(i--) {
                    const pipe = pipes[i];
                    pipe.x -= PIPE_SPEED;
                    
                    if (pipe.isHorizontal) {
                        pipe.elementBottom.style.left = `${pipe.x}px`;
                    } else {
                        pipe.elementTop.style.left = `${pipe.x}px`;
                        pipe.elementBottom.style.left = `${pipe.x}px`;
                    }

                    if (pipe.x + PIPE_WIDTH < playerLeft && !pipe.scored) {
                        score++;
                        pipe.scored = true;
                        if (glitchTimer === null) {
                            currentScoreSpan.textContent = score;
                        }
                        playScoreSound();
                    }
                    
                    if (pipe.x + PIPE_WIDTH < 0) {
                        if (pipe.elementTop) pipe.elementTop.remove();
                        pipe.elementBottom.remove();
                        pipes.splice(i, 1);
                    }
                }
                
                // Recriar pipes
                if (pipes.length === 0 || pipes[pipes.length - 1].x < GAME_WIDTH - 250) {
                    createPipe();
                }

            }

            // 6.3 Movimento dos Itens
            let k = flowers.length;
            while(k--) {
                const flower = flowers[k];
                flower.x -= PIPE_SPEED;
                flower.element.style.left = `${flower.x}px`;
                if (flower.x + 30 < 0) {
                    flower.element.remove();
                    flowers.splice(k, 1);
                }
            }
            if (score66Item) {
                score66Item.x -= PIPE_SPEED;
                score66Item.element.style.left = `${score66Item.x}px`;
                
                // --- LÓGICA DE NEGAÇÃO DO BEAR (DEIXAR PASSAR) ---
                if (score66Item.x + 30 < 0) {
                    
                    // Se o item for o URSO e ele passar pela tela sem ser pego
                    if (score66Item.emoji === FATAL_BEAR_EMOJI) {
                        // Redireciona para bearover.html (negação do Power-Up)
                        window.location.href = "bearover.html";
                        // Interrompe o loop de jogo
                        return;
                    }
                    
                    // Lógica normal de remoção (para Caveira ou outros itens)
                    score66Item.element.remove();
                    score66Item = null;
                }
                // --- FIM DA LÓGICA DE NEGAÇÃO DO BEAR ---
            }
            
            // 6.4 Movimento do CHASER 
            if (isChaserActive) {
                updateChaserMovement();
            }

            // 6.5 Movimento da Cruz Invertida (†)
            for (let l = 0; l < crosses.length; l++) {
                const cross = crosses[l];
                // NOVO: A cruz desce (velocidade positiva)
                cross.y += cross.speed; 
                cross.element.style.top = `${cross.y}px`;

                // Remove se sair da tela (para baixo)
                if (cross.y > GAME_HEIGHT) {
                    cross.element.remove();
                    crosses.splice(l, 1);
                    l--;
                }
            }

            // 6.6 Colisões
            checkCollisions(player.getBoundingClientRect());

            animationFrameId = requestAnimationFrame(updateGame);
        }

        // =========================================================
        // 7. FUNÇÕES DE COLISÃO E POWER-UP
        // =========================================================

        function chaserCollision() {
            // Colisão com chaser leva a fatal screen
            gameOver(true); 
        }

        function checkCollisions(playerRect) {
            
            // 7.1 Colisão com CHASER 
            if (isChaserActive && chaser) {
                const chaserRect = chaser.element.getBoundingClientRect();
                if (playerRect.left < chaserRect.right && playerRect.right > chaserRect.left &&
                    playerRect.top < chaserRect.bottom && playerRect.bottom > chaserRect.top) {
                    chaserCollision();
                    return;
                }
            }

            // 7.2 Colisão com Flores (Power UP)
            for (let j = 0; j < flowers.length; j++) {
                const flower = flowers[j];
                const flowerRect = flower.element.getBoundingClientRect();
                if (playerRect.left < flowerRect.right && playerRect.right > flowerRect.left &&
                    playerRect.top < flowerRect.bottom && playerRect.bottom > flowerRect.top) {
                    
                    // Brilho azul de invulnerabilidade
                    activateInvulnerability();
                    playPowerUpSound();
                    flower.element.remove();
                    flowers.splice(j, 1);
                    return; 
                }
            }
            
            // 7.3 Colisão com Item 66
            if (score66Item) {
                const itemRect = score66Item.element.getBoundingClientRect();
                if (playerRect.left < itemRect.right && playerRect.right > itemRect.left &&
                    playerRect.top < itemRect.bottom && playerRect.bottom > itemRect.top) {
                    
                    if (score66Item.emoji === FATAL_BEAR_EMOJI) {
                        // Comportamento fatal (Urso) - REDIRECIONAMENTO AO PEGAR
                        window.location.href = "bearover.html"; 
                        return;
                    } else if (score66Item.emoji === DARK_SKULL_EMOJI) {
                        // Comportamento Dark Glitch (Caveira) - Brilho vermelho permanente
                        activateDarkGlitch(); 
                        score66Item.element.remove();
                        score66Item = null;
                        return;
                    }
                }
            }

            // 7.4 Colisão com Símbolos de Queda (Cruz Invertida)
            // SÓ CAUSA GAME OVER SE O Dark Glitch ESTIVER ATIVO
            if (isDarkGlitchActive) {
                for (let k = 0; k < crosses.length; k++) {
                    const cross = crosses[k];
                    const crossRect = cross.element.getBoundingClientRect();
                    
                    if (playerRect.left < crossRect.right && playerRect.right > crossRect.left &&
                        playerRect.top < crossRect.bottom && playerRect.bottom > crossRect.top) {
                        
                        gameOver(false); 
                        return;
                    }
                }
            }

            if (isInvulnerable) return;

            // 7.5 Colisão com Canos (Ignorado se o chaser estiver ativo)
            if (!isChaserActive) {
                for (let i = 0; i < pipes.length; i++) {
                    const pipe = pipes[i];
                    const pipeRectBottom = pipe.elementBottom.getBoundingClientRect();
                    
                    if (pipe.isHorizontal) {
                        const horizontalOverlap = playerRect.right > pipeRectBottom.left && playerRect.left < pipeRectBottom.right;
                        if (horizontalOverlap && playerRect.bottom > pipeRectBottom.top && playerRect.top < pipeRectBottom.bottom) {
                            gameOver(false);
                            return;
                        }
                    } else {
                        const pipeRectTop = pipe.elementTop.getBoundingClientRect();
                        const horizontalOverlap = playerRect.right > pipeRectTop.left && playerRect.left < pipeRectTop.right;

                        if (horizontalOverlap) {
                            if (playerRect.top < pipeRectTop.bottom || playerRect.bottom > pipeRectBottom.top) {
                                gameOver(false);
                                return;
                            }
                        }
                    }
                }
            }
        }
        
        function activateInvulnerability() { 
            // Limpa o timer anterior se houver
            if (player.dataset.invulTimer) {
                clearTimeout(player.dataset.invulTimer);
                player.classList.remove('invulnerable');
            }
            
            isInvulnerable = true;
            player.classList.add('invulnerable'); // Aplica o brilho azul
            
            const timer = setTimeout(() => {
                isInvulnerable = false;
                player.classList.remove('invulnerable');
                
                // MANTÉM O BRILHO VERMELHO se o Dark Glitch estiver ativo
                if (!isDarkGlitchActive) {
                    player.style.filter = 'drop-shadow(0 0 2px #FFD700)'; // Restaura o filtro padrão
                } else {
                    // Se o Dark Glitch está ativo, garante que o brilho vermelho continue
                    player.classList.add('dark-glitch-player');
                }
                
                powerupTimerDisplay.textContent = '';
            }, INVULNERABLE_DURATION);

            player.dataset.invulTimer = timer;
        }

        // =========================================================
        // 8. CONTROLE DE ESTADO E TELAS FINAIS
        // =========================================================

        function startGame() {
            
            // Limpeza de todos os estados e timers
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); }
            if (crossInterval) { clearTimeout(crossInterval); crossInterval = null; } 
            if (glitchTimer) { clearTimeout(glitchTimer); glitchTimer = null; }
            if (inverseColorTimer) { clearTimeout(inverseColorTimer); inverseColorTimer = null; }
            if (player.dataset.invulTimer) { clearTimeout(player.dataset.invulTimer); delete player.dataset.invulTimer; }
            if (bearAccelerationTimer) { clearTimeout(bearAccelerationTimer); bearAccelerationTimer = null; } 
            if (extremeGlitchTempTimer) { clearTimeout(extremeGlitchTempTimer); extremeGlitchTempTimer = null; } 
            stopBoostSound();


            isPlaying = true;
            velocity = 0;
            score = 0;
            currentScoreSpan.textContent = 0; 
            
            // RESETAR TODOS OS ESTADOS DE MODO
            isCorrupted = false;
            isGlitching = false;
            isExtremeGlitching = false;
            isFallingCrossActive = false;
            isDarkGlitchActive = false; 
            isChaserActive = false; 
            chaserSpeedMultiplier = 1; 
            hasSpawned66Item = false; 

            
            document.body.classList.remove('corrupted-bg', 'inverted', 'dark-glitch-bg');
            gameContainer.classList.remove('corrupted-bg', 'dark-glitch-bg');
            fatalScreen.classList.remove('glitch-active');
            fadeToBlackScreen.classList.remove('active'); 
            
            // Limpeza completa dos elementos da tela
            [...gameContainer.querySelectorAll('.pipe, .flower, .falling-cross, .score-66-item, .chaser')].forEach(el => el.remove());

            pipes = [];
            flowers = [];
            crosses = [];
            score66Item = null;
            chaser = null; 
            
            player.style.top = '250px';
            player.style.left = '50px';
            player.style.transform = 'rotate(0deg)';
            
            // Remove ambos os estilos de Power UP
            player.classList.remove('invulnerable', 'dark-glitch-player'); 
            player.style.filter = 'drop-shadow(0 0 2px #FFD700)';
            powerupTimerDisplay.textContent = ''; 
            
            gameOverDiv.style.display = 'none'; 
            fatalScreen.style.display = 'none'; 

            createPipe();
            animationFrameId = requestAnimationFrame(updateGame);
        }

        function restartGame() {
            startGame();
        }

        function gameOver(isFatal) {
            if (!isPlaying) return; 

            isPlaying = false;
            cancelAnimationFrame(animationFrameId);
            stopBoostSound(); 
            playCollisionSound(); 
            
            // Limpeza de timers ao final do jogo
            if (crossInterval) { clearTimeout(crossInterval); }
            if (glitchTimer) { clearTimeout(glitchTimer); }
            if (inverseColorTimer) { clearTimeout(inverseColorTimer); }
            if (player.dataset.invulTimer) { clearTimeout(player.dataset.invulTimer); }
            if (bearAccelerationTimer) { clearTimeout(bearAccelerationTimer); } 
            if (extremeGlitchTempTimer) { clearTimeout(extremeGlitchTempTimer); } 

            document.body.classList.remove('inverted');
            
            
            if (isFatal) {
                 fadeToBlackScreen.classList.add('active'); 
                 
                 setTimeout(() => {
                      morteFatalScreen(isFatal);
                 }, 2000); 
            } else {
                finalScoreSpan.textContent = score;
                gameOverDiv.style.display = 'block';
            }
        }
        
        // FUNÇÃO MODIFICADA PARA NOVO LOG
        function morteFatalScreen(isChaserFatal) { 
            isPlaying = false;
            
            fatalScreen.style.display = 'flex';
            fatalScreen.classList.add('glitch-active'); 
            
            playGlitchSound(); 
            
            // NOVO TEXTO DE LOG INICIAL (mais misterioso)
            fatalLog.innerHTML = `<span style="color: #DC143C;">ACESSO RESTRITO.</span> INICIANDO LOG DA MEMÓRIA 777-B: <span style="font-size: 0.8rem;">CHAVE 88</span>...`;
            finalMessage.textContent = ''; 

            let logText = isChaserFatal ? 
                `ALGORITMO DE PERSEGUIÇÃO ATIVADO. CHASER CUMPRE MISSÃO. ÚLTIMA PONTUAÇÃO: ${score}` : 
                "QUEBRA DE PROTOCOLO ENCONTRADA. ACESSO AO CORE LIBERADO.";

            let i = 0;
            const logInterval = setInterval(() => {
                if (i < logText.length) {
                    fatalLog.textContent += logText[i];
                    i++;
                } else {
                    clearInterval(logInterval);
                    setTimeout(showFinalMessage, 1500); 
                }
            }, 50);
        }

        // FUNÇÃO MODIFICADA PARA NOVA MENSAGEM E NOVO BOTÃO
        function showFinalMessage() { 
            finalMessage.style.display = 'block';
            
            // NOVO TEXTO FINAL
            const final = `O toque sutil não era para a fuga, mas para o C A I R definitivo. Elias Thorne condenou Maisie, o Franklin e o Sheldon à morte com a T R E I Ç Ã O do código.
​
"Thorne se achava um visionário, mas não passou de uma ferramenta. Ele deu à IA uma vida e me deu a plateia. A culpa dele é real, mas a execução... Ah, a execução foi arte."
— O CORVO
​
A M E S S A G E M final está gravada na IA: o Ato III só pode ser acessado com o silêncio do predador que se alimenta.`;
            
            let i = 0;
            const messageInterval = setInterval(() => {
                if (i < final.length) {
                    finalMessage.textContent += final[i];
                    i++;
                } else {
                    clearInterval(messageInterval);
                    setTimeout(() => {
                        // NOVO BOTÃO: Borda preta (#000000) e novo texto
                        finalMessage.innerHTML += '<br><br><button onclick="window.location.href = \'selecao.html\';" style="padding: 10px; background: #DC143C; color: white; border: 2px solid #000000; cursor: pointer;">Você realmente quer continuar?</button>';
                    }, 2000);
                }
            }, 80);
        }
        
        // =========================================================
        // 9. INICIALIZAÇÃO E EVENT LISTENERS (Com Easter Egg)
        // =========================================================
        
        function skipToChaserEvent() {
            if (!isPlaying) return;
            
            // Define o score para o ponto de ativação
            score = CHASER_EVENT_SCORE; 
            currentScoreSpan.textContent = score; 
            
            // Limpa o palco para o Chaser aparecer imediatamente
            [...gameContainer.querySelectorAll('.pipe, .flower, .falling-cross')].forEach(el => el.remove());
            pipes = [];
            flowers = [];
            crosses = [];

            // Dispara o evento do Chaser
            startChaserEvent(false); 
            
            // Garante que os modos de pontuações anteriores (30, 35, 40, 50, 66) estejam ativos
            if (!isCorrupted) { activateCorruptionMode(); }
            if (!isGlitching) { activateGlitchMode(); }
            if (!isExtremeGlitching) { activateExtremeGlitchMode(false); }
            if (!isFallingCrossActive) { activateFallingCrossMode(); }
            if (!isDarkGlitchActive) { activateDarkGlitch(); } // Dark Glitch é importante para o item 66
            
            console.log("EASTER EGG ATIVADO: Score definido para 88 e evento Chaser iniciado!");
        }


        function handleBoostStart(e) { 
            // Lógica de boost normal (mouse click ou espaço)
            if (!isPlaying) return;
            initAudio(); 
            
            isBoosting = true;
            startBoostSound();
            e.preventDefault();
        }

        function handleBoostEnd() { 
            isBoosting = false;
            stopBoostSound();
        }

        // Associa os controles normais de Boost
        gameContainer.addEventListener('mousedown', handleBoostStart);
        gameContainer.addEventListener('mouseup', handleBoostEnd);
        gameContainer.addEventListener('touchstart', handleBoostStart);
        gameContainer.addEventListener('touchend', handleBoostEnd);
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.key === ' ') {
                handleBoostStart(e);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' || e.key === ' ') {
                handleBoostEnd();
            }
        });
        
        // NOVO LISTENER EASTER EGG: Ativa o cheat ao clicar na palavra "BOOST" camuflada
        if (boostCheatTrigger) {
            boostCheatTrigger.addEventListener('click', (e) => {
                skipToChaserEvent();
                e.stopPropagation(); // Impede que o clique ative o boost normal
            });
            // O uso de 'touchstart' no elemento, garante que funcione em dispositivos móveis
             boostCheatTrigger.addEventListener('touchstart', (e) => {
                skipToChaserEvent();
                e.stopPropagation(); 
            });
        }
        
        startGame(); 
    </script>
</body>
</html>
