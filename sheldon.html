<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flap of Despair - Sheldon, o Camar√£o</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="gameover_handler.js" defer></script>

    <style>
        /* --- ESTILOS GERAIS E LAYOUT --- */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #87CEEB, #4682B4); /* Base colorida fofinha */
            font-family: 'Press Start 2P', monospace;
            color: #000000;
            overflow: hidden;
            transition: background 2s ease;
        }menu
        body.pesadelo {
            background: linear-gradient(to bottom, #001122, #000011);
        }
        canvas {
            border: 3px solid #32CD32; /* Verde neon base */
            box-shadow: 0 0 20px rgba(50, 205, 50, 0.5); /* Brilho verde inicial */
            transition: border-color 2s ease, box-shadow 2s ease, background 2s ease;
            cursor: pointer;
        }
        canvas.pesadelo {
            border-color: #8B0000; /* Vermelho sangue no pesadelo */
            box-shadow: 0 0 20px rgba(139, 0, 0, 0.5);
            background: #000000; /* Preto no pesadelo */
        }

        /* --- ELEMENTOS DA INTERFACE --- */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }
        .voltar-btn {
            padding: 5px 10px;
            background: #FFFFFF;
            border: 2px solid #32CD32;
            color: #000000;
            font-size: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .voltar-btn:hover {
            background: #32CD32;
            color: #FFFFFF;
            border-color: #228B22;
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #000000;
            text-align: center;
            font-size: 0.6rem;
            text-shadow: 1px 1px 0 #FFFFFF;
            z-index: 10;
            transition: color 2s ease, text-shadow 2s ease;
        }
        #instructions.pesadelo {
            color: #8B0000;
            text-shadow: 1px 1px 0 #000000;
        }
        #score {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1rem;
            color: #32CD32;
            text-shadow: 1px 1px 0 #000000;
            z-index: 10;
            transition: color 2s ease;
            animation: none;
        }
        #score.pesadelo {
            color: #8B0000;
        }
        #score.blink {
            animation: blink-666 0.5s infinite;
        }
        @keyframes blink-666 {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        /* --- TELA DE GAME OVER --- */
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFFFFF;
            text-align: center;
            font-size: 1rem;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border: 2px solid #8B0000;
            border-radius: 5px;
            display: none;
            z-index: 20;
        }
        #gameOver h2 {
            color: #FFFFFF;
        }
        #gameOver.pesadelo h2 {
            color: #DC143C;
        }
        #errorCode {
            font-size: 1.5rem;
            color: #DC143C;
            animation: blink-error 0.5s infinite;
            margin: 10px 0;
            display: none;
        }
        @keyframes blink-error {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        #gameOver button {
            margin: 5px;
            padding: 10px;
            background: #555555;
            border: 2px solid #8B0000;
            color: #FFFFFF;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.8rem;
        }
        #gameOver button:hover {
            background: #666666;
            border-color: #DC143C;
            box-shadow: 0 0 10px #8B0000;
        }
        /* Estilo para o clique secreto */
        #gameOver #finalScore.clickable {
            cursor: pointer;
            color: #DC143C;
            text-decoration: underline;
        }
        #gameOver #finalScore.clickable:hover {
            color: #FF0000;
        }

        /* --- TELA PRETA (MORTE FATAL) --- */
        #blackScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            display: none;
            z-index: 30;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
            flex-direction: column; /* Para empilhar mensagens */
        }
        #cryptoMessage {
            color: #DC143C;
            font-size: 1rem;
            text-align: center;
            text-shadow: 2px 2px 0 #000000;
            animation: glitch 0.1s infinite, tremor-intenso 0.1s infinite; /* Tremor mais intenso */
            white-space: pre-wrap;
            margin-bottom: 20px;
        }
        /* Defini√ß√£o de Tremor Intenso */
        @keyframes tremor-intenso {
            0% { transform: translate(0, 0); }
            20% { transform: translate(-3px, 3px); }
            40% { transform: translate(3px, -3px); }
            60% { transform: translate(-3px, 3px); }
            80% { transform: translate(3px, -3px); }
            100% { transform: translate(0, 0); }
        }
        #dotsMessage {
            color: #DC143C;
            font-size: 3rem;
            text-align: center;
            animation: blink-dots 1s infinite;
            display: none;
        }
        @keyframes blink-dots {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        #finalMessage {
            color: #FFFFFF;
            font-size: 1.5rem;
            text-align: center;
            text-shadow: 2px 2px 0 #000000;
            font-weight: bold;
            display: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <button class="voltar-btn" onclick="window.location.href='gameover.html'">VOLTAR AO MENU</button>
    </div>
    <div id="instructions">Clique ou ESPA√áO para flap! Lute contra o peso... ü¶ê</div>
    <div id="score">Pontos: 0</div>

    <canvas id="gameCanvas" width="400" height="600"></canvas>

    <div id="gameOver">
        <h2 id="goTitle">Game Over</h2>
        <div id="errorCode"></div>
        <p>Pontua√ß√£o Final: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">Jogar Novamente</button>
        <button onclick="window.location.href='gameover.html'">MENU</button>
    </div>

    <div id="blackScreen">
        <div id="cryptoMessage"></div>
        <div id="dotsMessage">...</div>
        <div id="finalMessage">FLAP_DO_666</div>
    </div>


    <script>
    // --- VARI√ÅVEIS GLOBAIS DO DOM E ESTADO ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDiv = document.getElementById('score');
    const gameOverDiv = document.getElementById('gameOver');
    const goTitle = document.getElementById('goTitle');
    const errorCodeDiv = document.getElementById('errorCode');
    const finalScoreSpan = document.getElementById('finalScore');
    const blackScreen = document.getElementById('blackScreen');
    const cryptoMessage = document.getElementById('cryptoMessage');
    const dotsMessage = document.getElementById('dotsMessage'); // Novo: Tr√™s pontinhos
    const finalMessage = document.getElementById('finalMessage'); // Novo: T√≠tulo final
    const body = document.body;
    const instructions = document.getElementById('instructions');

    let shrimp, pipes, score, gameRunning, frame, pesadeloMode, modo666;
    let baleiaAtiva, baleiaX, baleiaY, peixesMortos;
    let animationFrameId;

    // --- CONFIGURA√á√ïES DO JOGO (SHELDON) ---
    const initialShrimpState = { x: 50, y: 300, width: 40, height: 40, velocity: 0, gravity: 0.8, jump: -6 };
    const pipeGenerationFrequency = 120;
    const basePipeSpeed = 2;
    const pesadeloPipeSpeed = 3;
    const basePipeGap = 250;
    const pesadeloScoreThreshold = 20;
    const modo666ScoreThreshold = 66;
    const baleiaSize = 60;
    const baleiaPersecSpeed = 1.5;
    const baleiaHorizontalSpeed = 2.5;
    const morteFatalMessageDuration = 10000; // 10 segundos da mensagem criptografada
    const dotsDuration = 3000; // 3 segundos dos pontinhos
    const finalMessageDuration = 5000; // 5 segundos da mensagem final (antes de redirecionar)
    const redirectMenu = 'selecao.html';

    // --- √ÅUDIO (Simula√ß√£o com Web Audio API) ---
    let audioContext;
    let backgroundSoundInterval;

    function initAudio() {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    function playFlapSound() {
        initAudio();
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain); gain.connect(audioContext.destination);
        osc.frequency.value = pesadeloMode ? 150 : 400;
        gain.gain.setValueAtTime(0.2, audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        osc.start(); osc.stop(audioContext.currentTime + 0.2);
    }
    function playCollisionSound() {
        initAudio();
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain); gain.connect(audioContext.destination);
        osc.frequency.setValueAtTime(pesadeloMode ? 100 : 200, audioContext.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);
        gain.gain.setValueAtTime(0.3, audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
        osc.start(); osc.stop(audioContext.currentTime + 0.4);
    }
    function playScoreSound() {
        initAudio();
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain); gain.connect(audioContext.destination);
        osc.frequency.value = pesadeloMode ? 300 : 600;
        gain.gain.setValueAtTime(0.1, audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
        osc.start(); osc.stop(audioContext.currentTime + 0.1);
    }
    // Som de gotejamento/sussurro no pesadelo
    function startBackgroundSound() {
        stopBackgroundSound(); // Garante que apenas um loop esteja ativo
        if (pesadeloMode) {
            backgroundSoundInterval = setInterval(() => {
                initAudio();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain); gain.connect(audioContext.destination);
                osc.type = 'sawtooth';
                osc.frequency.value = 80;
                gain.gain.setValueAtTime(0.05, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);
                osc.start(); osc.stop(audioContext.currentTime + 0.8);
            }, 2000);
        }
    }
    function stopBackgroundSound() {
        if (backgroundSoundInterval) {
            clearInterval(backgroundSoundInterval);
            backgroundSoundInterval = null;
        }
    }

    // --- FUN√á√ÉO DE RESET/INICIALIZA√á√ÉO ---
    function resetGame(directTo666 = false) {
        cancelAnimationFrame(animationFrameId);
        stopBackgroundSound();

        // Reseta vari√°veis de estado
        shrimp = { ...initialShrimpState };
        pipes = [];
        score = directTo666 ? 66 : 0;
        gameRunning = true;
        frame = 0;
        pesadeloMode = directTo666;
        modo666 = directTo666;
        baleiaAtiva = directTo666;
        baleiaX = canvas.width;
        baleiaY = canvas.height / 2;
        peixesMortos = [];

        // Reseta a interface e estilos
        scoreDiv.textContent = modo666 ? '666' : `Pontos: ${score}`;
        scoreDiv.classList.toggle('blink', modo666);
        scoreDiv.classList.toggle('pesadelo', pesadeloMode);
        body.classList.toggle('pesadelo', pesadeloMode);
        canvas.classList.toggle('pesadelo', pesadeloMode);
        instructions.classList.toggle('pesadelo', pesadeloMode);
        gameOverDiv.style.display = 'none';
        blackScreen.style.display = 'none';
        errorCodeDiv.style.display = 'none';
        goTitle.textContent = 'Game Over';
        
        // Remove clique extra no score
        finalScoreSpan.classList.remove('clickable');
        finalScoreSpan.onmouseover = finalScoreSpan.onmouseout = finalScoreSpan.onclick = null;


        // Ativa sons se pesadelo
        if (pesadeloMode) {
            startBackgroundSound();
        }

        gameLoop();
    }

    // --- FUN√á√ÉO DE REINICIAR DO BOT√ÉO ---
    window.restartGame = function() {
        resetGame(false);
    }

    // --- L√ìGICA DE DESENHO E ATUALIZA√á√ÉO (FUN√á√ïES OMITIDAS PARA CONCIS√ÉO, MAS MANTIDAS NO C√ìDIGO) ---
    // (drawBackground, drawShrimp, drawPipes, drawBaleia, updateShrimp, generatePipes, updatePipes, updateBaleia)
    // ...

    // Desenhar Fundo
    function drawBackground() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (pesadeloMode) {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#001122');
            gradient.addColorStop(1, '#000011');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Peixes mortos flutuando (n√£o colid√≠veis)
            peixesMortos.forEach((peixe, index) => {
                peixe.y += peixe.speed;
                if (peixe.y > canvas.height) peixe.y = -20;
                ctx.font = '20px Arial';
                ctx.fillStyle = 'rgba(139, 0, 0, 0.5)';
                ctx.fillText('üêü', peixe.x, peixe.y);
            });
            while (peixesMortos.length < 3) {
                peixesMortos.push({ x: Math.random() * canvas.width, y: -20, speed: 1 + Math.random() * 2 });
            }
        } else {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#4682B4');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }

    // Desenhar Camar√£o (Emojis)
    function drawShrimp() {
        ctx.save();
        ctx.translate(shrimp.x + shrimp.width / 2, shrimp.y + shrimp.height / 2);
        ctx.rotate(shrimp.velocity * 0.05);
        ctx.font = '40px Arial';
        ctx.fillStyle = pesadeloMode ? '#FF69B4' : '#FF1493';
        ctx.fillText('ü¶ê', -20, 20);
        ctx.restore();
    }

    // Desenhar Canos
    function drawPipes() {
        pipes.forEach(pipe => {
            const pipeColor = pesadeloMode ? '#006400' : '#32CD32';
            const borderColor = pesadeloMode ? '#8B0000' : '#228B22';

            // Corpo do cano
            ctx.fillStyle = pipeColor;
            ctx.fillRect(pipe.x, 0, pipe.width, pipe.top);
            ctx.fillRect(pipe.x, canvas.height - pipe.bottom, pipe.width, pipe.bottom);
            
            // Tampa do cano
            ctx.fillStyle = borderColor;
            ctx.fillRect(pipe.x - 2, pipe.top - 20, pipe.width + 4, 20);
            ctx.fillRect(pipe.x - 2, canvas.height - pipe.bottom, pipe.width + 4, 20);

            // Detalhes vermelho-sangue
            if (pesadeloMode) {
                ctx.fillStyle = '#DC143C';
                ctx.fillRect(pipe.x + pipe.width / 4, pipe.top - 10, pipe.width / 2, 5);
                ctx.fillRect(pipe.x + pipe.width / 4, canvas.height - pipe.bottom + 15, pipe.width / 2, 5);
            }
        });
    }

    // Desenhar Baleia
    function drawBaleia() {
        if (baleiaAtiva) {
            ctx.save();
            ctx.globalAlpha = Math.sin(frame * 0.2) > 0 ? 1 : 0; // Pisca
            ctx.font = '60px Arial';
            ctx.fillStyle = '#8B0000';
            ctx.fillText('üê≥', baleiaX, baleiaY);
            ctx.restore();
        }
    }

    // L√≥gica de Atualiza√ß√£o (omitidas para concis√£o, mesma do c√≥digo anterior)
    function updateShrimp() {
        shrimp.velocity += shrimp.gravity;
        shrimp.y += shrimp.velocity;
        if (shrimp.y + shrimp.height > canvas.height || shrimp.y < 0) {
            gameOver();
        }
    }
    function generatePipes() {
        if (frame % pipeGenerationFrequency === 0) {
            const gap = basePipeGap;
            const minHeight = 50;
            const top = Math.random() * (canvas.height - gap - 2 * minHeight) + minHeight;
            pipes.push({ x: canvas.width, width: 60, top: top, bottom: canvas.height - top - gap, scored: false });
        }
    }
    function updatePipes() {
        const speed = pesadeloMode ? pesadeloPipeSpeed : basePipeSpeed;
        pipes.forEach((pipe, index) => {
            pipe.x -= speed;
            if (pipe.x + pipe.width < 0) { pipes.splice(index, 1); return; }
            if (shrimp.x < pipe.x + pipe.width && shrimp.x + shrimp.width > pipe.x &&
                (shrimp.y < pipe.top || shrimp.y + shrimp.height > canvas.height - pipe.bottom)) { gameOver(); }
            if (!modo666 && pipe.x + pipe.width < shrimp.x && !pipe.scored) {
                pipe.scored = true; score++; scoreDiv.textContent = `Pontos: ${score}`; playScoreSound();
                if (score >= pesadeloScoreThreshold && !pesadeloMode) activatePesadelo();
                if (score >= modo666ScoreThreshold && !modo666) activate666();
            }
        });
    }
    function updateBaleia() {
        if (!baleiaAtiva) return;
        baleiaX -= baleiaHorizontalSpeed;
        if (baleiaX + baleiaSize < 0) {
            baleiaX = canvas.width; baleiaY = Math.random() * (canvas.height - baleiaSize) + baleiaSize / 2;
        }
        if (baleiaY < shrimp.y - 10) baleiaY += baleiaPersecSpeed;
        if (baleiaY > shrimp.y + 10) baleiaY -= baleiaPersecSpeed;
        if (shrimp.x < baleiaX + baleiaSize && shrimp.x + shrimp.width > baleiaX &&
            shrimp.y < baleiaY + baleiaSize && shrimp.y + shrimp.height > baleiaY) {
            morteFatal();
        }
    }


    // --- MODOS E GAME OVER ---

    function activatePesadelo() {
        pesadeloMode = true;
        body.classList.add('pesadelo');
        canvas.classList.add('pesadelo');
        instructions.classList.add('pesadelo');
        scoreDiv.classList.add('pesadelo');
        startBackgroundSound();
    }

    function activate666() {
        modo666 = true;
        scoreDiv.textContent = '666';
        scoreDiv.classList.add('blink');
        score = 666;
        baleiaAtiva = true;
        baleiaX = canvas.width;
        baleiaY = canvas.height / 2;
    }

    // Game Over por Canos/Ch√£o
    function gameOver() {
        if (!gameRunning) return;
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        playCollisionSound();
        stopBackgroundSound();

        finalScoreSpan.textContent = score;
        goTitle.textContent = 'Game Over';
        errorCodeDiv.style.display = 'none';
        gameOverDiv.classList.remove('pesadelo');

        if (pesadeloMode) {
            goTitle.textContent = 'ERRO DE EXECU√á√ÉO';
            gameOverDiv.classList.add('pesadelo');
            errorCodeDiv.textContent = 'ERRO: 3533';
            errorCodeDiv.style.display = 'block';
        }

        // Condi√ß√£o para pular ao 666 no Game Over (score 0)
        if (score === 0) {
            finalScoreSpan.classList.add('clickable');
            finalScoreSpan.title = 'Clique para pular ao terror final (Modo 666)';
            finalScoreSpan.onclick = () => resetGame(true);
        }

        gameOverDiv.style.display = 'block';
    }

    // Morte Fatal (Baleia)
    function morteFatal() {
        if (!gameRunning) return;
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        playCollisionSound();
        stopBackgroundSound();

        blackScreen.style.display = 'flex';
        cryptoMessage.textContent = '5L145, 0 4F064M5N70 F01 CULP4 5U4. V0C3 54B14 D0 P550 D5L5. L5MBR4 D4 4GU4 FR14?';
        
        cryptoMessage.style.display = 'block';
        dotsMessage.style.display = 'none';
        finalMessage.style.display = 'none';

        // 1. Exibe a mensagem criptografada (10s)
        setTimeout(() => {
            cryptoMessage.style.display = 'none';
            dotsMessage.style.display = 'block';
        }, morteFatalMessageDuration);

        // 2. Exibe os tr√™s pontinhos (3s)
        setTimeout(() => {
            dotsMessage.style.display = 'none';
            finalMessage.style.display = 'block';
        }, morteFatalMessageDuration + dotsDuration);

        // 3. Retorno ao menu (5s ap√≥s a mensagem final, total 18s)
        setTimeout(() => {
            window.location.href = redirectMenu;
        }, morteFatalMessageDuration + dotsDuration + finalMessageDuration);
    }

    // Flap
    function flap() {
        if (!gameRunning) return;
        shrimp.velocity = shrimp.jump;
        playFlapSound();
    }

    // Loop Principal
    function gameLoop() {
        if (!gameRunning) return;

        // Desenho
        drawBackground();
        drawShrimp();
        drawPipes();
        if (modo666) drawBaleia();

        // L√≥gica
        updateShrimp();
        generatePipes();
        updatePipes();
        if (modo666) updateBaleia();

        frame++;
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- EVENT LISTENERS E INICIALIZA√á√ÉO ---
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault();
            // Inicializa √°udio no primeiro clique/tecla (necess√°rio para alguns navegadores)
            if (!audioContext) initAudio();
            flap();
        }
    });
    canvas.addEventListener('click', () => {
        if (!audioContext) initAudio();
        flap();
    });

    window.addEventListener('load', () => {
        resetGame(false);
    });
    /* * FUN√á√ÉO DE MANUSEIO DE GAME OVER (Para ser usada em sheldon.html, franklin.html, maisie.html)
 * * Esta fun√ß√£o salva a URL da p√°gina de jogo atual no localStorage e, em seguida,
 * redireciona o jogador para a p√°gina gameover.html.
 */
function handleGameOver() {
    // 1. **Salva a URL da p√°gina atual no localStorage.**
    // O gameover.html usar√° esta chave ('gameover_return_page') para saber para onde voltar.
    // Usamos window.location.href para obter a URL completa (ex: 'http://.../sheldon.html').
    localStorage.setItem('gameover_return_page', window.location.href);

    // Opcional: Adiciona um pequeno log no console para facilitar a depura√ß√£o.
    console.log(`[Game Over Handler] Salvando URL de retorno: ${window.location.href}`);
    
    // 2. **Redireciona o jogador para a tela de Game Over.**
    // Certifique-se de que o caminho ('gameover.html') est√° correto.
    window.location.href = 'gameover.html';
}

// ----------------------------------------------------------------------------------
// EXEMPLO DE USO:
// 
// Para acionar o Game Over quando o jogador falhar, basta chamar handleGameOver().
// Voc√™ pode anexar esta fun√ß√£o a qualquer evento de falha no seu c√≥digo.
//
// Exemplo em sheldon.html:
// if (playerCollided()) {
//     handleGameOver();
// }
// ----------------------------------------------------------------------------------

</script>
    
</body>
</html>
